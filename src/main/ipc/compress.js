const fs = require('fs');
const Queue = require('better-queue');
const path = require('path');
const tmp = require('tmp');
const JSZip = require("jszip");

const imagemin = require('imagemin');
const imageminGifsicle = require('imagemin-gifsicle');
const imageminMozjpeg = require('imagemin-mozjpeg');
const imageminPngquant = require('imagemin-pngquant');
const imageminSvgo = require('imagemin-svgo');
const hbjs = require('handbrake-js');

const Terser = require("terser");
const CleanCSS = require('clean-css');
const HTMLminify = require('html-minifier').minify;

const videoFileTypes = ['.mp4', '.MP4', '.mkv', '.MKV', '.mov', '.MOV', 'm4v', 'M4V'];
const photoFileTypes = ['.jpg', '.JPG', '.jpeg', '.JPEG', '.png', '.PNG', '.svg', '.SVG', '.gif', '.GIF'];
const photoResizeFileTypes = ['.jpg', '.JPG', '.jpeg', '.JPEG', '.png', '.PNG'];
const webFileTypes = ['.html', '.HTML', '.css', '.CSS', '.js', '.JS'];
const zipFileTypes = ['.zip', '.docx', '.pptx', '.xlsx'];
const OUTPUT_path = './output/';

const imageMinPlugins = [
    imageminMozjpeg({quality: 80}),
    imageminPngquant({quality: [0.6, 0.8]}),
    imageminGifsicle({optimizationLevel: 2}),
    imageminSvgo({ plugins: [ {
      removeTitle: true,
      removeDimensions: true
    } ]})
  ];

const HTMLMinifySettings = {
    "collapseBooleanAttributes": true,
    "collapseInlineTagWhitespace" : true,
    "collapseWhitespace" : true,
    "includeAutoGeneratedTags" : false,
    "minifyCSS" : true,
    "minifyJS" : true,
    "minifyURLs" : true,
    "quoteCharacter": "'",
    "removeAttributeQuotes": true,
    "removeComments": true,
    "removeEmptyAttributes" : true,
    "removeEmptyElements": true,
    "removeOptionalTags": true,
    "removeRedundantAttributes": true,
    "removeScriptTypeAttributes": true,
    "removeStyleLinkTypeAttributes": true,
    "removeTagWhitespace" :true
}

export default class Compress {
    constructor() {
        this.addToQueue = this.addToQueue.bind(this);
        this.compressImages = this.compressImages.bind(this);
        this.compressImageBuffer = this.compressImageBuffer.bind(this);
        this.compressVideos = this.compressVideos.bind(this);
        //this.compressVideoBuffer = this.compressVideoBuffer.bind(this);
        this.compressWeb = this.compressWeb.bind(this);
        this.compressZip = this.compressZip.bind(this);

        this.videoQueue = new Queue(function (file, endTask) {
            console.log("from videoQueue:", file)
            hbjs.spawn({ 
                input: file,
                output: OUTPUT_path + path.basename(file), 
                preset: 'Vimeo YouTube HQ 1080p60' })
            .on('error', console.error)
            .on('progress', progress => {
                console.log(
                'Percent complete: %s, ETA: %s',
                progress.percentComplete,
                progress.eta
                )})
            .on('end', () => {
                console.log("Done!");
                endTask();
            });
        }, { batchSize: 1, concurrent: 1 })
        this.compressVideoBuffer = new Queue((file, tmpDir, tmpName, endTask) => {
            hbjs.spawn({ 
                input: tmpobj.name + tmpName,
                output: tmpDir + path.basename(file), 
                preset: 'Vimeo YouTube HQ 1080p60' })
            .on('error', console.error)
            .on('progress', progress => {
                console.log(
                'Percent complete: %s, ETA: %s',
                progress.percentComplete,
                progress.eta
                )})
            .on('end', () => {
                console.log("Done!");
                endTask();
            });
        }, { batchSize: 1, concurrent: 1 })
        
    }

    async addToQueue(event, files) {
        try {
            console.log("Number of files:", files.length);
            console.log(files)
            for (const file of files) {
                if (photoFileTypes.includes(path.extname(file))) {
                    await this.compressImages(file);   
                }
                if (videoFileTypes.includes(path.extname(file))) {
                    await this.videoQueue.push(file);
                    //this.compressVideos(file);
                    //this.videoQueue.push(file);   
                }
                if (zipFileTypes.includes(path.extname(file))) {
                    await this.compressZip(file);
                }
            }   
        }
        catch(error) {
            console.error('Error:', error);
        }
    }

    

    async compressImages(file) {
        try {
            await fs.readFile(file, async (err, data) => {
                if (err) throw err;
                const processedFile = await this.compressImageBuffer(data);
                await fs.writeFile(OUTPUT_path + path.basename(file), processedFile, err => console.error(err))
            });
        } catch(err) {
          console.error('Error: ', err);
        }
      }

    async compressImageBuffer(buffer) {
        try {
            return await imagemin.buffer(buffer, { plugins: imageMinPlugins });
        } catch(err) {
            console.error(err);
        }
    }

    async compressVideos(file, endTask) {
        //add promise here
        
        hbjs.spawn({ 
            input: file,
            output: OUTPUT_path + path.basename(file), 
            preset: 'Vimeo YouTube HQ 1080p60' })
        .on('error', console.error)
        .on('progress', progress => {
            console.log(
            'Percent complete: %s, ETA: %s',
            progress.percentComplete,
            progress.eta
            )})
        .on('end', () => {
            console.log("Done!");
            endTask();

        });

    }

    // async compressVideoBuffer(file, tempPath, endTask) {
    //     //add promise here

        
    //     hbjs.spawn({ 
    //         input: file,
    //         output: tempPath + path.basename(file), 
    //         preset: 'Vimeo YouTube HQ 1080p60' })
    //     .on('error', console.error)
    //     .on('progress', progress => {
    //         console.log(
    //         'Percent complete: %s, ETA: %s',
    //         progress.percentComplete,
    //         progress.eta
    //         )})
    //     .on('end', () => {
    //         console.log("Done!");
    //         endTask();
    //     });
    // }

    async compressWeb(file) {

    }

    async compressWebBuffer(buffer, file) {
        const webText = buffer.toString('utf-8');
        let result = null;
        if (path.extname(file) === '.html'){
            result = HTMLminify(webText, HTMLMinifySettings);
        }
        if (path.extname(file) === '.css'){
            result = new CleanCSS({level: 2}).minify(webText).styles;
        }
        if (path.extname(file) === '.js'){
            result = Terser.minify(webText).code;
        }
        return Buffer.from(result, 'utf-8');
    }

    async compressZip(file) {
        fs.readFile(file, async (err, data) => {
            if (err) throw err;
            const zip = await JSZip.loadAsync(data);
            const allFiles = Object.keys(zip.files).filter((file) => {
                if (photoFileTypes.includes(path.extname(file))) { return file };
                if (videoFileTypes.includes(path.extname(file))) { return file };
                if (webFileTypes.includes(path.extname(file))) { return file };
            });
            console.log("Number of Files:", allFiles.length);

            for (const file of allFiles) {
                const content = await zip.file(file).async("nodebuffer", metadata => console.log("progression: " + metadata.percent.toFixed(2) + " %"));
                let processedContent = null;
                if (photoFileTypes.includes(path.extname(file))) {
                    processedContent = await this.compressImageBuffer(content);
                }

                if (videoFileTypes.includes(path.extname(file))) {
                    //Still need to process video content in handbrake
                    // const tmpobj = tmp.dirSync();
                    // const tmpName = tmp.tmpNameSync();
                    // console.log(tmpName);
                    // await fs.writeFile(tmpobj.name + tmpName, content, (err) => {console.error(err)});
                    
                    //await this.compressVideoBuffer.push(file, tmpobj.name, tmpName);
                    //processedContent = fs.readFileSync(tmpobj.name + path.basename(file))
                    processedContent = content;
                }

                if (webFileTypes.includes(path.extname(file))) {
                    processedContent = await this.compressWebBuffer(content, file);
                }

                console.log("File:", allFiles.indexOf(file), "of", allFiles.length);
                zip.file(file, processedContent, {binary: true})
            }

            const zipContent = await zip.generateAsync({type:"nodebuffer", compression: "DEFLATE"}, metadata => {
                console.log("progression: " + metadata.percent.toFixed(2) + " %")})
            fs.writeFile(OUTPUT_path + path.basename(file), zipContent, function(err){/*...*/});
            
            // tmpobj.removeCallback();
        });
    }
}