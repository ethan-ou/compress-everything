const fs = require('fs-extra');
const path = require('path');
const tmp = require('tmp');
const JSZip = require('jszip');
const extract = require('extract-zip');
const readdirp = require('readdirp');
import PQueue from 'p-queue';

const imagemin = require('imagemin');
const imageminGifsicle = require('imagemin-gifsicle');
const imageminMozjpeg = require('imagemin-mozjpeg');
const imageminPngquant = require('imagemin-pngquant');
const imageminSvgo = require('imagemin-svgo');
const Jimp = require('jimp');
const hbjs = require('handbrake-js');

const Terser = require('terser');
const CleanCSS = require('clean-css');
const HTMLminify = require('html-minifier').minify;

const videoFileTypes = ['.mp4', '.MP4', '.mkv', '.MKV', '.mov', '.MOV', 'm4v', 'M4V', '.mpeg', '.MPEG'];
const photoFileTypes = ['.jpg', '.JPG', '.jpeg', '.JPEG', '.png', '.PNG', '.svg', '.SVG', '.gif', '.GIF'];
const photoResizeFileTypes = ['.jpg', '.JPG', '.jpeg', '.JPEG', '.png', '.PNG'];
const jpegFileTypes = ['.jpg', '.JPG', '.jpeg', '.JPEG'];
const pngFileTypes = ['.png', '.PNG'];
const webFileTypes = ['.html', '.HTML', '.css', '.CSS', '.js', '.JS'];
const zipFileTypes = ['.zip', '.docx', '.pptx', '.xlsx', '.epub'];
const resizeZipFileTypes = ['.zip', '.docx', '.pptx', '.xlsx'];

const OUTPUT_path = './output/';

const imageMinPlugins = [
    imageminMozjpeg({ quality: 80 }),
    imageminPngquant({ quality: [0.6, 0.8] }),
    imageminGifsicle({ optimizationLevel: 2 }),
    imageminSvgo({
        plugins: [
            {
                removeTitle: true,
                removeDimensions: true,
            },
        ],
    }),
];

const HTMLMinifySettings = {
    collapseBooleanAttributes: true,
    collapseInlineTagWhitespace: true,
    collapseWhitespace: true,
    includeAutoGeneratedTags: false,
    minifyCSS: true,
    minifyJS: true,
    minifyURLs: true,
    quoteCharacter: "'",
    removeAttributeQuotes: true,
    removeComments: true,
    removeEmptyAttributes: true,
    removeEmptyElements: true,
    removeOptionalTags: true,
    removeRedundantAttributes: true,
    removeScriptTypeAttributes: true,
    removeStyleLinkTypeAttributes: true,
    removeTagWhitespace: true,
};

const resizeImages = [2048, 2048];

const mainQueue = new PQueue({concurrency: 3});
const altQueue = new PQueue({concurrency: 1});

export async function addToQueue(event, files) {
    console.log('Number of files:', files.length);
    console.log(files);

    fs.ensureDir(OUTPUT_path, err => {
        console.log(err)
    })  

    const [photo, video, web, zip, rejected] = await sortFiles(files);
    await Promise.all([
        photo.map(async file => await mainQueue.add(async () => await openFile(file, "photo"))),
        web.map(async file => await mainQueue.add(async () => await openFile(file, "web"))),
        video.map(async file => await altQueue.add(async () => await compressVideos(file))),
        zip.map(async file => await altQueue.add(async () => await compressZip(file)))
    ])
    .then(values => console.log("Done!", values))
    .catch(error => console.log(error))
    
    if (rejected) console.log(`Rejected ${rejected}`);
    console.log(`Queue size: ${mainQueue.size}`);
    console.log(`Queue size: ${altQueue.size}`);
}

async function sortFiles(files) {
    //const photo, video, web, zip, rejected = [];
    //const fileTypes = [...photoFileTypes, ...videoFileTypes, ...webFileTypes, ...zipFileTypes];

    // for (file of files) {
    //     let fileExt = path.extname(file);
    //     if (photoFileTypes.includes(fileExt)) photo.push(file);
    //     if (videoFileTypes.includes(fileExt)) video.push(file);
    //     if (webFileTypes.includes(fileExt)) web.push(file);
    //     if (zipFileTypes.includes(fileExt)) zip.push(file);
    //     if (!fileTypes.includes(fileExt)) rejected.push(file);
    // }

    const photo = files.filter(file => photoFileTypes.includes(path.extname(file)));
    const video = files.filter(file => videoFileTypes.includes(path.extname(file)));
    const web = files.filter(file => webFileTypes.includes(path.extname(file)));
    const zip = files.filter(file => zipFileTypes.includes(path.extname(file)));

    const rejected = files.filter(file => {
        const fileTypes = [...photoFileTypes, ...videoFileTypes, ...webFileTypes, ...zipFileTypes];
        return !fileTypes.includes(path.extname(file))
    });

    return [photo, video, web, zip, rejected]
}

async function openFile(file, type) {
    let promise = new Promise(async (resolve, reject) => {
        await fs.readFile(file, async (err, data) => {
            if (err) reject(err);
           
            let processed;
            if (type == "photo") processed = await compressImageBuffer(data, file);
            if (type == "web") processed = await compressWebBuffer(data, file);
            
            await fs.writeFile(OUTPUT_path + path.basename(file), processed, err => {
                if (err) reject(err);
                else resolve("done");
            });
        })
    })
    return promise
}


async function compressImages(file) {
    let promise = new Promise(async (resolve, reject) => {
        try {
            await fs.readFile(file, async (err, data) => {
                if (err) reject(err);
                
                let fileData = data;
                
                if (resizeImages && photoResizeFileTypes.includes(path.extname(file))) {
                    fileData = await resizeImage(fileData, path.extname(file));
                }
                
                const processedFile = await compressImageBuffer(fileData);
                
                await fs.writeFile(OUTPUT_path + path.basename(file), processedFile, (err) => {
                    if (err) reject(err);
                    else resolve("done");
                });
            });
        } catch (err) {
            reject(err);
        }
    })
    
    return promise;
}

async function compressImageBuffer(buffer, file, resize = true) {
    let promise = new Promise(async (resolve, reject) => {
        try {
            console.log(buffer);
            const resizedImage = await resizeImage(buffer, file, resize);
            const processed = await imagemin.buffer(resizedImage, { plugins: imageMinPlugins });
            resolve(processed);
        } catch (err) {
            reject(err);
        }
    });

    return promise;
}

async function resizeImage(buffer, file, resize) {
    let mime;
    const fileType = path.extname(file);
    if (!resizeImages || !photoResizeFileTypes.includes(fileType) || !resize) return buffer;
    if (jpegFileTypes.includes(fileType)) mime = Jimp.MIME_JPEG;
    if (pngFileTypes.includes(fileType)) mime = Jimp.MIME_PNG;
    const image = await Jimp.read(buffer)
        .then(image => {
            if (image.bitmap.width > resizeImages[0] || image.bitmap.height > resizeImages[1]) {
                image.scaleToFit(resizeImages[0], resizeImages[1], Jimp.RESIZE_BICUBIC);
            }
            return image.getBufferAsync(mime);
        })
        .catch(err => {
            console.error(err);
        });

    return image;
}

async function compressVideos(file) {
    let promise = new Promise(async (resolve, reject) => {
        hbjs.spawn({
            input: file,
            output: OUTPUT_path + path.basename(file),
            preset: 'Vimeo YouTube HQ 1080p60',
        })
        .on('error', (err) => {
            reject(err);
        })
        .on('progress', (progress) => {
            console.log(
                'Percent complete: %s, ETA: %s',
                progress.percentComplete,
                progress.eta,
            );
        })
        .on('end', () => {
            console.log('Done!');
            resolve("Done");
        });
    })
    return promise;
}

async function compressWeb(file) {
    let promise = new Promise(async (resolve, reject) => {
        try {
            await fs.readFile(file, async (err, data) => {
                if (err) reject(err);
                const processedFile = await compressWebBuffer(data, file);
                await fs.writeFile(OUTPUT_path + path.basename(file), processedFile, err => {
                    if (err) reject(err);
                    else resolve("done");
                });
            });
        } catch (err) {
            console.error('Error: ', err);
        }
    })
    return promise;
}

async function compressWebBuffer(buffer, file) {
    let promise = new Promise(async (resolve, reject) => {
        try {
            const data = buffer.toString('ucs2');
            let fileType = path.extname(file);
            let result;            
            if (fileType === '.html') {
                result = HTMLminify(data, HTMLMinifySettings);
            }
            if (fileType === '.css') {
                result = new CleanCSS({ level: 2 }).minify(data).styles;
            }
            if (fileType === '.js') {
                result = Terser.minify(data).code;
            }
            resolve(Buffer.from(result, 'ucs2'));
        } catch (err) {
            reject(err);
        }
        return promise;
    })
}

async function compressZip(file) {
    let promise = new Promise(async (resolve, reject) => {
        fs.readFile(file, async (err, data) => {
            if (err) reject(err);

            const zip = await JSZip.loadAsync(data);
            const allFiles = Object.keys(zip.files);
            const sortedFiles = await sortFiles(allFiles);
            const processedZip = await processZip(zip, sortedFiles);

            processedZip.generateNodeStream({
                streamFiles: true,
                compression: 'DEFLATE',
                compressionOptions: {
                    level: 9,
                },
            })
            .pipe(fs.createWriteStream(OUTPUT_path + path.basename(file)))
            .on('finish', () => {
                console.log(path.basename(file), 'written.');
                resolve("done");
            });
        });
    })

    return promise;
}

async function processZip(zip, files) {
    const [photoFiles, videoFiles, webFiles, zipFiles, rejectedFiles] = files;
    const containsWebFile = webFiles.length > 0 ? true : false;
    const acceptedFiles = [...photoFiles, ...videoFiles, ...webFiles];

    for (const file of acceptedFiles) {
        const data = await zip
            .file(file)
            .async('nodebuffer', metadata => console.log(`progression: ${metadata.percent.toFixed(2)} %`));

        let processedData;
        if (photoFileTypes.includes(path.extname(file))) {
            let resize;
            if (containsWebFile) {
                console.log("Resizing");
                resize = false;
            } else {
                resize = true;
            }
            processedData = await compressImageBuffer(data, file, resize);
        }

        if (videoFileTypes.includes(path.extname(file))) {
            processedData = data;
        }

        if (webFileTypes.includes(path.extname(file))) {
            processedData = await compressWebBuffer(data, file);
        }

        console.log('File:', acceptedFiles.indexOf(file) + 1, 'of', acceptedFiles.length);
        zip.file(file, processedData, { binary: true });
    }

    return zip;
}